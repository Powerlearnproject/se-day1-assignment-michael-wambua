[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18364439&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.

    software engineering is a branch of computer science used for developing, testing and maintaining software.Its importance are:
         reliability- it ensures software performs as expected without bias especially for critical applications like healthcare ,finance. 
         efficiency - it helps to optimize developer workflow while maintaining high quality standards.
         scalability and flexibility - it ensures that the system can handle an increased load without affecting performance.
         security - implement protection practice like authentication, authorization and encryption to secure users information


Identify and describe at least three key milestones in the evolution of software engineering.

    1. Mastering Complexity (1960s–1970s)
        In the early days of software development, managing complexity was a significant challenge, as software systems grew in size and functionality. To address this, structured programming emerged in the 1970s, focusing on clear, logical structures in code to make            programs easier to understand and maintain. Key figures like Edsger Dijkstra emphasized breaking down software into smaller, manageable pieces, leading to more modular designs. Modular programming further supported this by allowing developers to work on                  independent parts of the system, improving maintainability and reducing complexity in large software projects.

    2. Mastering Process (1980s–1990s)
        As software projects became larger and more complex, the need for a systematic approach to development grew. The Waterfall model, introduced in the 1970s, formalized the software development process by breaking it into distinct, sequential phases like                    requirements gathering, design, and testing. However, by the early 2000s, the limitations of Waterfall—its rigidity and slow response to change—led to the rise of Agile methodologies. Agile emphasized iterative development, flexibility, and collaboration,                transforming   the software development process and allowing teams to be more adaptive and responsive to evolving requirements.
        
     3. Mastering Machine (2000s–Present)
        With advancements in hardware capabilities and the rise of cloud technologies, the 2000s marked a new era in software engineering, where mastering the machine itself became central. Cloud computing allowed for the scalable and flexible deployment of software             without the need for extensive on-premise infrastructure, leading to more efficient resource management and cost savings. Additionally, machine learning and AI technologies became integrated into software, enabling systems to learn, adapt, and make data-driven           decisions, opening up new possibilities in automation, personalization, and complex problem-solving across industries.


List and briefly explain the phases of the Software Development Life Cycle.

        planning - identify the software requirement or purpose and scope.
        requirement analysis - identify the final user specification. 
        design - building the framework. 
        coding - converting software design into tangible code.
        testing - examine the software for any bugs and glitches



Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.


Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.


Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.


What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.


Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.


#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.


Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
